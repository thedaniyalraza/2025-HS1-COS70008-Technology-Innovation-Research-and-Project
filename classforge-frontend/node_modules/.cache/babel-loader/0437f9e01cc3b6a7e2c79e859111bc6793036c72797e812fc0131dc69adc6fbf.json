{"ast":null,"code":"import { Pass } from './Pass.js';\n\n/**\n * This pass can be used to define a mask during post processing.\n * Meaning only areas of subsequent post processing are affected\n * which lie in the masking area of this pass. Internally, the masking\n * is implemented with the stencil buffer.\n *\n * ```js\n * const maskPass = new MaskPass( scene, camera );\n * composer.addPass( maskPass );\n * ```\n *\n * @augments Pass\n */\nclass MaskPass extends Pass {\n  /**\n   * Constructs a new mask pass.\n   *\n   * @param {Scene} scene - The 3D objects in this scene will define the mask.\n   * @param {Camera} camera - The camera.\n   */\n  constructor(scene, camera) {\n    super();\n\n    /**\n     * The scene that defines the mask.\n     *\n     * @type {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The camera.\n     *\n     * @type {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Overwritten to perform a clear operation by default.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    this.clear = true;\n\n    /**\n     * Overwritten to disable the swap.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.needsSwap = false;\n\n    /**\n     * Whether to inverse the mask or not.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.inverse = false;\n  }\n\n  /**\n   * Performs a mask pass with the configured scene and camera.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {\n    const context = renderer.getContext();\n    const state = renderer.state;\n\n    // don't update color or depth\n\n    state.buffers.color.setMask(false);\n    state.buffers.depth.setMask(false);\n\n    // lock buffers\n\n    state.buffers.color.setLocked(true);\n    state.buffers.depth.setLocked(true);\n\n    // set up stencil\n\n    let writeValue, clearValue;\n    if (this.inverse) {\n      writeValue = 0;\n      clearValue = 1;\n    } else {\n      writeValue = 1;\n      clearValue = 0;\n    }\n    state.buffers.stencil.setTest(true);\n    state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n    state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n    state.buffers.stencil.setClear(clearValue);\n    state.buffers.stencil.setLocked(true);\n\n    // draw into the stencil buffer\n\n    renderer.setRenderTarget(readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera);\n    renderer.setRenderTarget(writeBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.scene, this.camera);\n\n    // unlock color and depth buffer and make them writable for subsequent rendering/clearing\n\n    state.buffers.color.setLocked(false);\n    state.buffers.depth.setLocked(false);\n    state.buffers.color.setMask(true);\n    state.buffers.depth.setMask(true);\n\n    // only render where stencil is set to 1\n\n    state.buffers.stencil.setLocked(false);\n    state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n    state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n    state.buffers.stencil.setLocked(true);\n  }\n}\n\n/**\n * This pass can be used to clear a mask previously defined with {@link MaskPass}.\n *\n * ```js\n * const clearPass = new ClearMaskPass();\n * composer.addPass( clearPass );\n * ```\n *\n * @augments Pass\n */\nclass ClearMaskPass extends Pass {\n  /**\n   * Constructs a new clear mask pass.\n   */\n  constructor() {\n    super();\n\n    /**\n     * Overwritten to disable the swap.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.needsSwap = false;\n  }\n\n  /**\n   * Performs the clear of the currently defined mask.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {\n    renderer.state.buffers.stencil.setLocked(false);\n    renderer.state.buffers.stencil.setTest(false);\n  }\n}\nexport { MaskPass, ClearMaskPass };","map":{"version":3,"names":["Pass","MaskPass","constructor","scene","camera","clear","needsSwap","inverse","render","renderer","writeBuffer","readBuffer","context","getContext","state","buffers","color","setMask","depth","setLocked","writeValue","clearValue","stencil","setTest","setOp","REPLACE","setFunc","ALWAYS","setClear","setRenderTarget","EQUAL","KEEP","ClearMaskPass"],"sources":["C:/Users/draza/classforge/classforge-frontend/node_modules/three/examples/jsm/postprocessing/MaskPass.js"],"sourcesContent":["import { Pass } from './Pass.js';\n\n/**\n * This pass can be used to define a mask during post processing.\n * Meaning only areas of subsequent post processing are affected\n * which lie in the masking area of this pass. Internally, the masking\n * is implemented with the stencil buffer.\n *\n * ```js\n * const maskPass = new MaskPass( scene, camera );\n * composer.addPass( maskPass );\n * ```\n *\n * @augments Pass\n */\nclass MaskPass extends Pass {\n\n\t/**\n\t * Constructs a new mask pass.\n\t *\n\t * @param {Scene} scene - The 3D objects in this scene will define the mask.\n\t * @param {Camera} camera - The camera.\n\t */\n\tconstructor( scene, camera ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene that defines the mask.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * Overwritten to perform a clear operation by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clear = true;\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t/**\n\t\t * Whether to inverse the mask or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.inverse = false;\n\n\t}\n\n\t/**\n\t * Performs a mask pass with the configured scene and camera.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst context = renderer.getContext();\n\t\tconst state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tlet writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer and make them writable for subsequent rendering/clearing\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\tstate.buffers.color.setMask( true );\n\t\tstate.buffers.depth.setMask( true );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n}\n\n/**\n * This pass can be used to clear a mask previously defined with {@link MaskPass}.\n *\n * ```js\n * const clearPass = new ClearMaskPass();\n * composer.addPass( clearPass );\n * ```\n *\n * @augments Pass\n */\nclass ClearMaskPass extends Pass {\n\n\t/**\n\t * Constructs a new clear mask pass.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t}\n\n\t/**\n\t * Performs the clear of the currently defined mask.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n}\n\nexport { MaskPass, ClearMaskPass };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}