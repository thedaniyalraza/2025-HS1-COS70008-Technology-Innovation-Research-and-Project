{"ast":null,"code":"import { ShaderMaterial, UniformsUtils } from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * This pass can be used to create a post processing effect\n * with a raw GLSL shader object. Useful for implementing custom\n * effects.\n *\n * ```js\n * const fxaaPass = new ShaderPass( FXAAShader );\n * composer.addPass( fxaaPass );\n * ```\n *\n * @augments Pass\n */\nclass ShaderPass extends Pass {\n  /**\n   * Constructs a new shader pass.\n   *\n   * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as\n   * defines and uniforms. It's also valid to pass a custom shader material.\n   * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample\n   * the read buffer.\n   */\n  constructor(shader, textureID = 'tDiffuse') {\n    super();\n\n    /**\n     * The name of the texture uniform that should sample the read buffer.\n     *\n     * @type {string}\n     * @default 'tDiffuse'\n     */\n    this.textureID = textureID;\n\n    /**\n     * The pass uniforms.\n     *\n     * @type {?Object}\n     */\n    this.uniforms = null;\n\n    /**\n     * The pass material.\n     *\n     * @type {?ShaderMaterial}\n     */\n    this.material = null;\n    if (shader instanceof ShaderMaterial) {\n      this.uniforms = shader.uniforms;\n      this.material = shader;\n    } else if (shader) {\n      this.uniforms = UniformsUtils.clone(shader.uniforms);\n      this.material = new ShaderMaterial({\n        name: shader.name !== undefined ? shader.name : 'unspecified',\n        defines: Object.assign({}, shader.defines),\n        uniforms: this.uniforms,\n        vertexShader: shader.vertexShader,\n        fragmentShader: shader.fragmentShader\n      });\n    }\n\n    // internals\n\n    this._fsQuad = new FullScreenQuad(this.material);\n  }\n\n  /**\n   * Performs the shader pass.\n   *\n   * @param {WebGLRenderer} renderer - The renderer.\n   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n   * destination for the pass.\n   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n   * previous pass from this buffer.\n   * @param {number} deltaTime - The delta time in seconds.\n   * @param {boolean} maskActive - Whether masking is active or not.\n   */\n  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {\n    if (this.uniforms[this.textureID]) {\n      this.uniforms[this.textureID].value = readBuffer.texture;\n    }\n    this._fsQuad.material = this.material;\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this._fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n      if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n      this._fsQuad.render(renderer);\n    }\n  }\n\n  /**\n   * Frees the GPU-related resources allocated by this instance. Call this\n   * method whenever the pass is no longer used in your app.\n   */\n  dispose() {\n    this.material.dispose();\n    this._fsQuad.dispose();\n  }\n}\nexport { ShaderPass };","map":{"version":3,"names":["ShaderMaterial","UniformsUtils","Pass","FullScreenQuad","ShaderPass","constructor","shader","textureID","uniforms","material","clone","name","undefined","defines","Object","assign","vertexShader","fragmentShader","_fsQuad","render","renderer","writeBuffer","readBuffer","value","texture","renderToScreen","setRenderTarget","clear","autoClearColor","autoClearDepth","autoClearStencil","dispose"],"sources":["C:/Users/draza/classforge/classforge-frontend/node_modules/three/examples/jsm/postprocessing/ShaderPass.js"],"sourcesContent":["import {\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * This pass can be used to create a post processing effect\n * with a raw GLSL shader object. Useful for implementing custom\n * effects.\n *\n * ```js\n * const fxaaPass = new ShaderPass( FXAAShader );\n * composer.addPass( fxaaPass );\n * ```\n *\n * @augments Pass\n */\nclass ShaderPass extends Pass {\n\n\t/**\n\t * Constructs a new shader pass.\n\t *\n\t * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as\n\t * defines and uniforms. It's also valid to pass a custom shader material.\n\t * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample\n\t * the read buffer.\n\t */\n\tconstructor( shader, textureID = 'tDiffuse' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the texture uniform that should sample the read buffer.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'tDiffuse'\n\t\t */\n\t\tthis.textureID = textureID;\n\n\t\t/**\n\t\t * The pass uniforms.\n\t\t *\n\t\t * @type {?Object}\n\t\t */\n\t\tthis.uniforms = null;\n\n\t\t/**\n\t\t * The pass material.\n\t\t *\n\t\t * @type {?ShaderMaterial}\n\t\t */\n\t\tthis.material = null;\n\n\t\tif ( shader instanceof ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new ShaderMaterial( {\n\n\t\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// internals\n\n\t\tthis._fsQuad = new FullScreenQuad( this.material );\n\n\t}\n\n\t/**\n\t * Performs the shader pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis._fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.material.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n}\n\nexport { ShaderPass };\n"],"mappings":"AAAA,SACCA,cAAc,EACdC,aAAa,QACP,OAAO;AACd,SAASC,IAAI,EAAEC,cAAc,QAAQ,WAAW;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,UAAU,SAASF,IAAI,CAAC;EAE7B;AACD;AACA;AACA;AACA;AACA;AACA;AACA;EACCG,WAAWA,CAAEC,MAAM,EAAEC,SAAS,GAAG,UAAU,EAAG;IAE7C,KAAK,CAAC,CAAC;;IAEP;AACF;AACA;AACA;AACA;AACA;IACE,IAAI,CAACA,SAAS,GAAGA,SAAS;;IAE1B;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,QAAQ,GAAG,IAAI;;IAEpB;AACF;AACA;AACA;AACA;IACE,IAAI,CAACC,QAAQ,GAAG,IAAI;IAEpB,IAAKH,MAAM,YAAYN,cAAc,EAAG;MAEvC,IAAI,CAACQ,QAAQ,GAAGF,MAAM,CAACE,QAAQ;MAE/B,IAAI,CAACC,QAAQ,GAAGH,MAAM;IAEvB,CAAC,MAAM,IAAKA,MAAM,EAAG;MAEpB,IAAI,CAACE,QAAQ,GAAGP,aAAa,CAACS,KAAK,CAAEJ,MAAM,CAACE,QAAS,CAAC;MAEtD,IAAI,CAACC,QAAQ,GAAG,IAAIT,cAAc,CAAE;QAEnCW,IAAI,EAAIL,MAAM,CAACK,IAAI,KAAKC,SAAS,GAAKN,MAAM,CAACK,IAAI,GAAG,aAAa;QACjEE,OAAO,EAAEC,MAAM,CAACC,MAAM,CAAE,CAAC,CAAC,EAAET,MAAM,CAACO,OAAQ,CAAC;QAC5CL,QAAQ,EAAE,IAAI,CAACA,QAAQ;QACvBQ,YAAY,EAAEV,MAAM,CAACU,YAAY;QACjCC,cAAc,EAAEX,MAAM,CAACW;MAExB,CAAE,CAAC;IAEJ;;IAEA;;IAEA,IAAI,CAACC,OAAO,GAAG,IAAIf,cAAc,CAAE,IAAI,CAACM,QAAS,CAAC;EAEnD;;EAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACCU,MAAMA,CAAEC,QAAQ,EAAEC,WAAW,EAAEC,UAAU,CAAC,8BAA+B;IAExE,IAAK,IAAI,CAACd,QAAQ,CAAE,IAAI,CAACD,SAAS,CAAE,EAAG;MAEtC,IAAI,CAACC,QAAQ,CAAE,IAAI,CAACD,SAAS,CAAE,CAACgB,KAAK,GAAGD,UAAU,CAACE,OAAO;IAE3D;IAEA,IAAI,CAACN,OAAO,CAACT,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAErC,IAAK,IAAI,CAACgB,cAAc,EAAG;MAE1BL,QAAQ,CAACM,eAAe,CAAE,IAAK,CAAC;MAChC,IAAI,CAACR,OAAO,CAACC,MAAM,CAAEC,QAAS,CAAC;IAEhC,CAAC,MAAM;MAENA,QAAQ,CAACM,eAAe,CAAEL,WAAY,CAAC;MACvC;MACA,IAAK,IAAI,CAACM,KAAK,EAAGP,QAAQ,CAACO,KAAK,CAAEP,QAAQ,CAACQ,cAAc,EAAER,QAAQ,CAACS,cAAc,EAAET,QAAQ,CAACU,gBAAiB,CAAC;MAC/G,IAAI,CAACZ,OAAO,CAACC,MAAM,CAAEC,QAAS,CAAC;IAEhC;EAED;;EAEA;AACD;AACA;AACA;EACCW,OAAOA,CAAA,EAAG;IAET,IAAI,CAACtB,QAAQ,CAACsB,OAAO,CAAC,CAAC;IAEvB,IAAI,CAACb,OAAO,CAACa,OAAO,CAAC,CAAC;EAEvB;AAED;AAEA,SAAS3B,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}