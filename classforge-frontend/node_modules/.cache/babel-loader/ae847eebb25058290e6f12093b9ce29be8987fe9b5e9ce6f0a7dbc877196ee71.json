{"ast":null,"code":"import { DataTextureLoader, LinearMipmapLinearFilter } from 'three';\nclass TGALoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager);\n  }\n  parse(buffer) {\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n    function tgaCheckHeader(header) {\n      switch (header.image_type) {\n        // check indexed type\n\n        case TGA_TYPE_INDEXED:\n        case TGA_TYPE_RLE_INDEXED:\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n            throw new Error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n          }\n          break;\n\n        // check colormap type\n\n        case TGA_TYPE_RGB:\n        case TGA_TYPE_GREY:\n        case TGA_TYPE_RLE_RGB:\n        case TGA_TYPE_RLE_GREY:\n          if (header.colormap_type) {\n            throw new Error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n          }\n          break;\n\n        // What the need of a file without data ?\n\n        case TGA_TYPE_NO_DATA:\n          throw new Error('THREE.TGALoader: No data.');\n\n        // Invalid type ?\n\n        default:\n          throw new Error('THREE.TGALoader: Invalid type ' + header.image_type);\n      }\n\n      // check image width and height\n\n      if (header.width <= 0 || header.height <= 0) {\n        throw new Error('THREE.TGALoader: Invalid image size.');\n      }\n\n      // check image pixel size\n\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n        throw new Error('THREE.TGALoader: Invalid pixel size ' + header.pixel_size);\n      }\n    }\n\n    // parse tga image buffer\n\n    function tgaParse(use_rle, use_pal, header, offset, data) {\n      let pixel_data, palettes;\n      const pixel_size = header.pixel_size >> 3;\n      const pixel_total = header.width * header.height * pixel_size;\n\n      // read palettes\n\n      if (use_pal) {\n        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n      }\n\n      // read RLE\n\n      if (use_rle) {\n        pixel_data = new Uint8Array(pixel_total);\n        let c, count, i;\n        let shift = 0;\n        const pixels = new Uint8Array(pixel_size);\n        while (shift < pixel_total) {\n          c = data[offset++];\n          count = (c & 0x7f) + 1;\n\n          // RLE pixels\n\n          if (c & 0x80) {\n            // bind pixel tmp array\n\n            for (i = 0; i < pixel_size; ++i) {\n              pixels[i] = data[offset++];\n            }\n\n            // copy pixel array\n\n            for (i = 0; i < count; ++i) {\n              pixel_data.set(pixels, shift + i * pixel_size);\n            }\n            shift += pixel_size * count;\n          } else {\n            // raw pixels\n\n            count *= pixel_size;\n            for (i = 0; i < count; ++i) {\n              pixel_data[shift + i] = data[offset++];\n            }\n            shift += count;\n          }\n        }\n      } else {\n        // raw pixels\n\n        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n      }\n      return {\n        pixel_data: pixel_data,\n        palettes: palettes\n      };\n    }\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n      const colormap = palettes;\n      let color,\n        i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          color = image[i + 0] + (image[i + 1] << 8);\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001F) << 3;\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\n          imageData[(x + width * y) * 4 + 3] = 255;\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          imageData[(x + width * y) * 4 + 3] = image[i + 3];\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let color,\n        i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i++) {\n          color = image[i];\n          imageData[(x + width * y) * 4 + 0] = color;\n          imageData[(x + width * y) * 4 + 1] = color;\n          imageData[(x + width * y) * 4 + 2] = color;\n          imageData[(x + width * y) * 4 + 3] = 255;\n        }\n      }\n      return imageData;\n    }\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n      let i = 0,\n        x,\n        y;\n      const width = header.width;\n      for (y = y_start; y !== y_end; y += y_step) {\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\n          imageData[(x + width * y) * 4 + 0] = image[i + 0];\n          imageData[(x + width * y) * 4 + 1] = image[i + 0];\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\n          imageData[(x + width * y) * 4 + 3] = image[i + 1];\n        }\n      }\n      return imageData;\n    }\n    function getTgaRGBA(data, width, height, image, palette) {\n      let x_start, y_start, x_step, y_step, x_end, y_end;\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n        default:\n        case TGA_ORIGIN_UL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BL:\n          x_start = 0;\n          x_step = 1;\n          x_end = width;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n        case TGA_ORIGIN_UR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = 0;\n          y_step = 1;\n          y_end = height;\n          break;\n        case TGA_ORIGIN_BR:\n          x_start = width - 1;\n          x_step = -1;\n          x_end = -1;\n          y_start = height - 1;\n          y_step = -1;\n          y_end = -1;\n          break;\n      }\n      if (use_grey) {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 16:\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            throw new Error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      } else {\n        switch (header.pixel_size) {\n          case 8:\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n            break;\n          case 16:\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 24:\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          case 32:\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n            break;\n          default:\n            throw new Error('THREE.TGALoader: Format not supported.');\n            break;\n        }\n      }\n\n      // Load image data according to specific method\n      // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n      return data;\n    }\n\n    // TGA constants\n\n    const TGA_TYPE_NO_DATA = 0,\n      TGA_TYPE_INDEXED = 1,\n      TGA_TYPE_RGB = 2,\n      TGA_TYPE_GREY = 3,\n      TGA_TYPE_RLE_INDEXED = 9,\n      TGA_TYPE_RLE_RGB = 10,\n      TGA_TYPE_RLE_GREY = 11,\n      TGA_ORIGIN_MASK = 0x30,\n      TGA_ORIGIN_SHIFT = 0x04,\n      TGA_ORIGIN_BL = 0x00,\n      TGA_ORIGIN_BR = 0x01,\n      TGA_ORIGIN_UL = 0x02,\n      TGA_ORIGIN_UR = 0x03;\n    if (buffer.length < 19) throw new Error('THREE.TGALoader: Not enough data to contain header.');\n    let offset = 0;\n    const content = new Uint8Array(buffer),\n      header = {\n        id_length: content[offset++],\n        colormap_type: content[offset++],\n        image_type: content[offset++],\n        colormap_index: content[offset++] | content[offset++] << 8,\n        colormap_length: content[offset++] | content[offset++] << 8,\n        colormap_size: content[offset++],\n        origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n        width: content[offset++] | content[offset++] << 8,\n        height: content[offset++] | content[offset++] << 8,\n        pixel_size: content[offset++],\n        flags: content[offset++]\n      };\n\n    // check tga if it is valid format\n\n    tgaCheckHeader(header);\n    if (header.id_length + offset > buffer.length) {\n      throw new Error('THREE.TGALoader: No data.');\n    }\n\n    // skip the needn't data\n\n    offset += header.id_length;\n\n    // get targa information about RLE compression and palette\n\n    let use_rle = false,\n      use_pal = false,\n      use_grey = false;\n    switch (header.image_type) {\n      case TGA_TYPE_RLE_INDEXED:\n        use_rle = true;\n        use_pal = true;\n        break;\n      case TGA_TYPE_INDEXED:\n        use_pal = true;\n        break;\n      case TGA_TYPE_RLE_RGB:\n        use_rle = true;\n        break;\n      case TGA_TYPE_RGB:\n        break;\n      case TGA_TYPE_RLE_GREY:\n        use_rle = true;\n        use_grey = true;\n        break;\n      case TGA_TYPE_GREY:\n        use_grey = true;\n        break;\n    }\n\n    //\n\n    const imageData = new Uint8Array(header.width * header.height * 4);\n    const result = tgaParse(use_rle, use_pal, header, offset, content);\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n    return {\n      data: imageData,\n      width: header.width,\n      height: header.height,\n      flipY: true,\n      generateMipmaps: true,\n      minFilter: LinearMipmapLinearFilter\n    };\n  }\n}\nexport { TGALoader };","map":{"version":3,"names":["DataTextureLoader","LinearMipmapLinearFilter","TGALoader","constructor","manager","parse","buffer","tgaCheckHeader","header","image_type","TGA_TYPE_INDEXED","TGA_TYPE_RLE_INDEXED","colormap_length","colormap_size","colormap_type","Error","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_TYPE_NO_DATA","width","height","pixel_size","tgaParse","use_rle","use_pal","offset","data","pixel_data","palettes","pixel_total","subarray","Uint8Array","c","count","i","shift","pixels","set","tgaGetImageData8bits","imageData","y_start","y_step","y_end","x_start","x_step","x_end","image","colormap","color","x","y","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","getTgaRGBA","palette","flags","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_UL","TGA_ORIGIN_BL","TGA_ORIGIN_UR","TGA_ORIGIN_BR","use_grey","length","content","id_length","colormap_index","origin","result","flipY","generateMipmaps","minFilter"],"sources":["C:/Users/draza/classforge/classforge-frontend/node_modules/aframe-extras/node_modules/three/examples/jsm/loaders/TGALoader.js"],"sourcesContent":["import {\n\tDataTextureLoader,\n\tLinearMipmapLinearFilter\n} from 'three';\n\nclass TGALoader extends DataTextureLoader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tparse( buffer ) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader( header ) {\n\n\t\t\tswitch ( header.image_type ) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif ( header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1 ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type colormap data for indexed type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif ( header.colormap_type ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type colormap data for colormap type.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tthrow new Error( 'THREE.TGALoader: No data.' );\n\n\t\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid type ' + header.image_type );\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif ( header.width <= 0 || header.height <= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid image size.' );\n\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif ( header.pixel_size !== 8 && header.pixel_size !== 16 &&\n\t\t\t\theader.pixel_size !== 24 && header.pixel_size !== 32 ) {\n\n\t\t\t\tthrow new Error( 'THREE.TGALoader: Invalid pixel size ' + header.pixel_size );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse( use_rle, use_pal, header, offset, data ) {\n\n\t\t\tlet pixel_data,\n\t\t\t\tpalettes;\n\n\t\t\tconst pixel_size = header.pixel_size >> 3;\n\t\t\tconst pixel_total = header.width * header.height * pixel_size;\n\n\t\t\t // read palettes\n\n\t\t\t if ( use_pal ) {\n\n\t\t\t\t palettes = data.subarray( offset, offset += header.colormap_length * ( header.colormap_size >> 3 ) );\n\n\t\t\t }\n\n\t\t\t // read RLE\n\n\t\t\t if ( use_rle ) {\n\n\t\t\t\t pixel_data = new Uint8Array( pixel_total );\n\n\t\t\t\tlet c, count, i;\n\t\t\t\tlet shift = 0;\n\t\t\t\tconst pixels = new Uint8Array( pixel_size );\n\n\t\t\t\twhile ( shift < pixel_total ) {\n\n\t\t\t\t\tc = data[ offset ++ ];\n\t\t\t\t\tcount = ( c & 0x7f ) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif ( c & 0x80 ) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor ( i = 0; i < pixel_size; ++ i ) {\n\n\t\t\t\t\t\t\tpixels[ i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data.set( pixels, shift + i * pixel_size );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\n\t\t\t\t\t\tfor ( i = 0; i < count; ++ i ) {\n\n\t\t\t\t\t\t\tpixel_data[ shift + i ] = data[ offset ++ ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += count;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t } else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(\n\t\t\t\t\t offset, offset += ( use_pal ? header.width * header.height : pixel_total )\n\t\t\t\t);\n\n\t\t\t }\n\n\t\t\t return {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t };\n\n\t\t}\n\n\t\tfunction tgaGetImageData8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes ) {\n\n\t\t\tconst colormap = palettes;\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = colormap[ ( color * 3 ) + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = colormap[ ( color * 3 ) + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = colormap[ ( color * 3 ) + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\tcolor = image[ i + 0 ] + ( image[ i + 1 ] << 8 );\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = ( color & 0x7C00 ) >> 7;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = ( color & 0x03E0 ) >> 2;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = ( color & 0x001F ) << 3;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = ( color & 0x8000 ) ? 0 : 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData24bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 3 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageData32bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 4 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 1 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 2 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet color, i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i ++ ) {\n\n\t\t\t\t\tcolor = image[ i ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = color;\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = 255;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits( imageData, y_start, y_step, y_end, x_start, x_step, x_end, image ) {\n\n\t\t\tlet i = 0, x, y;\n\t\t\tconst width = header.width;\n\n\t\t\tfor ( y = y_start; y !== y_end; y += y_step ) {\n\n\t\t\t\tfor ( x = x_start; x !== x_end; x += x_step, i += 2 ) {\n\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 0 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 1 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 2 ] = image[ i + 0 ];\n\t\t\t\t\timageData[ ( x + width * y ) * 4 + 3 ] = image[ i + 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn imageData;\n\n\t\t}\n\n\t\tfunction getTgaRGBA( data, width, height, image, palette ) {\n\n\t\t\tlet x_start,\n\t\t\t\ty_start,\n\t\t\t\tx_step,\n\t\t\t\ty_step,\n\t\t\t\tx_end,\n\t\t\t\ty_end;\n\n\t\t\tswitch ( ( header.flags & TGA_ORIGIN_MASK ) >> TGA_ORIGIN_SHIFT ) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = - 1;\n\t\t\t\t\tx_end = - 1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = - 1;\n\t\t\t\t\ty_end = - 1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( use_grey ) {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tswitch ( header.pixel_size ) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits( data, y_start, y_step, y_end, x_start, x_step, x_end, image );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'THREE.TGALoader: Format not supported.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// TGA constants\n\n\t\tconst TGA_TYPE_NO_DATA = 0,\n\t\t\tTGA_TYPE_INDEXED = 1,\n\t\t\tTGA_TYPE_RGB = 2,\n\t\t\tTGA_TYPE_GREY = 3,\n\t\t\tTGA_TYPE_RLE_INDEXED = 9,\n\t\t\tTGA_TYPE_RLE_RGB = 10,\n\t\t\tTGA_TYPE_RLE_GREY = 11,\n\n\t\t\tTGA_ORIGIN_MASK = 0x30,\n\t\t\tTGA_ORIGIN_SHIFT = 0x04,\n\t\t\tTGA_ORIGIN_BL = 0x00,\n\t\t\tTGA_ORIGIN_BR = 0x01,\n\t\t\tTGA_ORIGIN_UL = 0x02,\n\t\t\tTGA_ORIGIN_UR = 0x03;\n\n\t\tif ( buffer.length < 19 ) throw new Error( 'THREE.TGALoader: Not enough data to contain header.' );\n\n\t\tlet offset = 0;\n\n\t\tconst content = new Uint8Array( buffer ),\n\t\t\theader = {\n\t\t\t\tid_length: content[ offset ++ ],\n\t\t\t\tcolormap_type: content[ offset ++ ],\n\t\t\t\timage_type: content[ offset ++ ],\n\t\t\t\tcolormap_index: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_length: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tcolormap_size: content[ offset ++ ],\n\t\t\t\torigin: [\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\t\tcontent[ offset ++ ] | content[ offset ++ ] << 8\n\t\t\t\t],\n\t\t\t\twidth: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\theight: content[ offset ++ ] | content[ offset ++ ] << 8,\n\t\t\t\tpixel_size: content[ offset ++ ],\n\t\t\t\tflags: content[ offset ++ ]\n\t\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader( header );\n\n\t\tif ( header.id_length + offset > buffer.length ) {\n\n\t\t\tthrow new Error( 'THREE.TGALoader: No data.' );\n\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tlet use_rle = false,\n\t\t\tuse_pal = false,\n\t\t\tuse_grey = false;\n\n\t\tswitch ( header.image_type ) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tconst imageData = new Uint8Array( header.width * header.height * 4 );\n\t\tconst result = tgaParse( use_rle, use_pal, header, offset, content );\n\t\tgetTgaRGBA( imageData, header.width, header.height, result.pixel_data, result.palettes );\n\n\t\treturn {\n\n\t\t\tdata: imageData,\n\t\t\twidth: header.width,\n\t\t\theight: header.height,\n\t\t\tflipY: true,\n\t\t\tgenerateMipmaps: true,\n\t\t\tminFilter: LinearMipmapLinearFilter,\n\n\t\t};\n\n\t}\n\n}\n\nexport { TGALoader };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}